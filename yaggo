#! /usr/bin/env ruby

require 'optparse'

options = {
  :lib => false,
  :prefix => nil,
  :local => false,
}
parser = OptionParser.new do |o|
  o.banner = "Usage: #{$0} [options] [file.yaggo]"
  o.separator ""
  o.separator "Specific options:"

  o.on("-l", "--lib", "Output yaggo.{cpp,hpp}") {
    options[:lib] = true
  }
  o.on("-p", "--prefix PATH", "Prefix to include yaggo.hpp") { |v|
    options[:prefix] = v
  }
  o.on("--local", "Local include (#include \"...\")") {
    options[:local] = true
  }


  o.on_tail("-h", "--help", "Show this message") {
    puts o
    exit 0
  }
end
parser.parse! ARGV
if !options[:lib] && ARGV.empty?
  STDERR.puts "Error: some yaggo files and/or --lib switch", parser
  exit 1
end

$typejust = 30
$switchesjust = 40

$type_to_C_type = { 
  :uint32 => "uint32_t",
  :uint64 => "uint64_t",
  :int32 => "int32_t",
  :int64 => "int64_t",
  :double => "double",
  :string => "yaggo::string",
  :c_string => "const char *",
}
$type_default = {
  :uint32 => "0",
  :uint64 => "0",
  :int32 => "0",
  :int64 => "0",
  :double => "0.0d",
  :string => "",
  :c_string => "",
}
def str_conv(arg, type, suffix)
  si_suffix = case suffix
              when true
                "true"
              when false
                "false"
              when String
                suffix
              else
                raise "Invalid suffix specifier"
              end
  case type
  when :string
    "yaggo::string(#{arg})"
  when :c_string
    arg
  when :uint32, :uint64
    "yaggo::conv_uint<#{$type_to_C_type[type]}>((const char *)#{arg}, err, #{si_suffix})"
  when :int32, :int64
    "yaggo::conv_int<#{$type_to_C_type[type]}>((const char *)#{arg}, err, #{si_suffix})"
  when :double
    "yaggo::conv_double((const char *)#{arg}, err, #{si_suffix})"
  end
end

# Path to include yaggo.hpp in C
$inc_path = options[:local] ? '"' : '<'
if options[:prefix]
  $inc_path += File.join(options[:prefix], "yaggo.hpp")
else
  $inc_path += "yaggo.hpp"
end
$inc_path += options[:local] ? '"' : '>'

##############################
# Output library
##############################
if options[:lib]
  open("yaggo.hpp", "w") do |fd|
    fd.puts(<<EOS)
#ifndef __YAGGO_HPP__
#define __YAGGO_HPP__

#include <stdint.h>
#include <stdlib.h>
#include <getopt.h>
#include <errno.h>
#include <string.h>
#include <stdexcept>
#include <string>
#include <limits>
#include <vector>
#include <iostream>
#include <sstream>

namespace yaggo {
  class string : public std::string {
  public:
    string() : std::string() {}
    string(const std::string &s) : std::string(s) {}
    string(const char *s) : std::string(s) {}
EOS
      
      [:uint32, :uint64, :int32, :int64, :double].each do |type|
        fd.puts(<<EOS)
    #{$type_to_C_type[type]} as_#{type}_suffix() const { return as_#{type}(true); }
    #{$type_to_C_type[type]} as_#{type}(bool si_suffix = false) const;
EOS
      end
      fd.puts(<<EOS)
  };

  bool adjust_double_si_suffix(double &res, const char *unit);
  double conv_double(const char *str, std::string &err, bool si_suffix);

  template<typename T>
  static bool adjust_int_si_suffix(T &res, const char *suffix) {
    if(*suffix == '\\0')
      return true;
    if(*(suffix + 1) != '\\0')
      return false;

    switch(*suffix) {
    case 'k': res *= (T)1000; break;
    case 'M': res *= (T)1000000; break;
    case 'G': res *= (T)1000000000; break;
    case 'T': res *= (T)1000000000000; break;
    case 'P': res *= (T)1000000000000000; break;
    case 'E': res *= (T)1000000000000000000; break;
    default: return false;
    }
    return true;
  }

  template<typename T>
  static T conv_int(const char *str, std::string &err, bool si_suffix) {
    char *endptr = 0;
    errno = 0;
    long long int res = strtoll(str, &endptr, 0);
    if(errno) {
      err.assign(strerror(errno));
      return (T)0;
    }
    bool invalid = 
      si_suffix ? !adjust_int_si_suffix(res, endptr) : *endptr != '\\0';
    if(invalid) {
      err.assign("Invalid character");
      return (T)0;
    }
    if(res > std::numeric_limits<T>::max() || 
       res < std::numeric_limits<T>::min()) {
      err.assign("Value out of range");
      return (T)0;
    }
    return (T)res;
  }

  template<typename T>
  static T conv_uint(const char *str, std::string &err, bool si_suffix) {
    char *endptr = 0;
    errno = 0;
    while(isspace(*str)) { ++str; }
    if(*str == '-') {
      err.assign("Negative value");
      return (T)0;
    }
    unsigned long long int res = strtoull(str, &endptr, 0);
    if(errno) {
      err.assign(strerror(errno));
      return (T)0;
    }
    bool invalid =
      si_suffix ? !adjust_int_si_suffix(res, endptr) : *endptr != '\\0';
    if(invalid) {
      err.assign("Invalid character");
      return (T)0;
    }
    if(res > std::numeric_limits<T>::max() || 
       res < std::numeric_limits<T>::min()) {
      err.assign("Value out of range");
      return (T)0;
    }
    return (T)res;
  }

  template<typename T>
  static std::string vec_str(const std::vector<T> &vec) {
    std::ostringstream os;
    for(typename std::vector<T>::const_iterator it = vec.begin();
        it != vec.end(); ++it) {
      if(it != vec.begin())
        os << ",";
      os << *it;
    }
    return os.str();
  }
  
}

#endif
EOS

    end 
  
  open("yaggo.cpp", "w") do |fd|
    fd.puts(<<EOS)
#include #{$inc_path}

namespace yaggo {
EOS

    [:uint32, :uint64, :int32, :int64, :double].each do |type|
      fd.puts(<<EOS)
  #{$type_to_C_type[type]} string::as_#{type}(bool si_suffix) const {
    std::string err;
    #{$type_to_C_type[type]} res = #{str_conv("this->c_str()", type, "si_suffix")};
    if(!err.empty()) {
      std::string msg("Invalid conversion of '");
      msg += *this;
      msg += "' to #{type}_t: ";
      msg += err;
      throw std::runtime_error(msg);
    }
    return res;
  }

EOS
    end

    fd.puts(<<EOS)
  bool adjust_double_si_suffix(double &res, const char *suffix) {
    if(*suffix == '\\0')
      return true;
    if(*(suffix + 1) != '\\0')
      return false;

    switch(*suffix) {
    case 'a': res *= 1e-18; break;
    case 'f': res *= 1e-15; break;
    case 'p': res *= 1e-12; break;
    case 'n': res *= 1e-9;  break;
    case 'u': res *= 1e-6;  break;
    case 'm': res *= 1e-3;  break;
    case 'k': res *= 1e3;   break;
    case 'M': res *= 1e6;   break;
    case 'G': res *= 1e9;   break;
    case 'T': res *= 1e12;  break;
    case 'P': res *= 1e15;  break;
    case 'E': res *= 1e18;  break;
    default: return false;
    }
    return true;
  }

  double conv_double(const char *str, std::string &err, bool si_suffix) {
    char *endptr = 0;
    errno = 0;
    double res = strtod(str, &endptr);
    if(errno) {
      err.assign(strerror(errno));
      return (double)0.0;
    }
    bool invalid =
      si_suffix ? !adjust_double_si_suffix(res, endptr) : *endptr != '\\0';
    if(invalid) {
      err.assign("Invalid character");
      return (double)0.0;
    }
    return res;
  }
}
EOS

  end
end

##############################
# Process an input files
##############################
$options = []
$args = []

class NoTarget
  def description str; $description = str; end
  def description= str; $description = str; end
  def method_missing(m, *args)
    raise "#{m} outside of option description"
  end
end
$target = NoTarget.new

def output str; $output = str; end
def name str; $class = str; end
def name str; $class = str; end
def purpose str; $purpose = str; end
def package str; $package = str; end
def description str; $target.description = str; end
def version str; $version = str; end

def int32; $target.type = :int32; end
def int64; $target.type = :int64; end
def uint32; $target.type = :uint32; end
def uint64; $target.type = :uint64; end
def double; $target.type = :double; end
def suffix; $target.suffix = true; end
def string; $target.type = :string; end
def c_string; $target.type = :c_string; end
def required; $target.required = true; end
def hidden; $target.hidden = true; end
def flag; $target.type = :flag; end
def on; $target.default = "true"; end
def off; $target.default = "false"; end
def default str; $target.default = str; end
def typestr str; $target.typestr = str; end
def multiple; $target.multiple = true; end
def at_least n; $target.at_least = n; end

def default_val(val, type)
  res = ""
  res += '"' if @type == :string || @type == :c_string
  res += val || $type_default[@type]
  res += '"' if @type == :string || @type == :c_string
  res
end

class Option
  attr_accessor :description, :type, :required, :default, :typestr
  attr_accessor :hidden, :multiple, :suffix
  attr_reader :long, :short, :var

  def initialize(long, short)
    @long, @short = long, short
    @var = (@long || @short).gsub(/[^a-zA-Z0-9_]/, "_")
    @type = :string
    @suffix = false
  end

  def check
    pref = "Option #{long || ""}|#{short || ""}:"
    case @type
      when :uint32, :uint64
      @default.nil? || @default =~ /\d+/ or
        raise "#{pref} Invalid unsigned integer #{@default} for #{@long || @short}"
      when :int32, :int64
      @default.nil? || @default =~ /[+-]?\d+/ or
        raise "#{pref} Invalid integer #{@default} for #{@long || @short}"
      when :double
      @default.nil? || @default =~ /[+-][\d.]+([eE][+-]?\d+)?/ or
        raise "#{pref} Invalid double #{@default} for #{@long || @short}"
      when :flag
      raise "#{pref} A flag cannot be declared multiple" if @multiple
      raise "#{pref} Suffix is meaningless for a flag" if @suffix
    end
  end

  def var_decl
    if @type == :flag
      ["#{"bool".ljust($typejust)} #{@var}_flag;"]
    else
      a = []
      if @multiple
        a << ("std::vector<#{$type_to_C_type[@type]}>".ljust($typejust) + " #{@var}_arg;")
      else
        a << "#{$type_to_C_type[@type].ljust($typejust)} #{@var}_arg;"
      end
      a << "#{"bool".ljust($typejust)} #{@var}_given;"
    end
  end

  def init
    s = "#{@var}_#{@type == :flag ? "flag" : "arg"}("
    s += default_val(@default, @type) unless @multiple
    s += ")"
    unless @type == :flag
      s += ", #{@var}_given(false)"
    end
    s
  end

  def long_enum; @short.nil? ? @var.upcase + "_OPT" : nil; end
  def struct
    "{\"#{long}\", #{@type == :flag ? 0 : 1}, 0, #{@short ? "'" + @short + "'" : long_enum}}"
  end
  def short_str
    return nil if @short.nil?
    @short + (@type == :flag ? "" : ":")
  end
  def switches
    s  = @short.nil? ? "    " : "-#{@short}"
    s += ", " unless @short.nil? || @long.nil?
    unless @long.nil?
      s += "--#{@long}"
      s += "=#{@typestr || @type}" unless @type == :flag
    end
    s
  end

  def help
    s  = @required ? "*" : " "
    s += @description || "No description"
    s += " (#{@default})" unless @default.nil?
    s
  end

  def dump
    if @type == :flag
      ["\"#{@var}_flag:\"", "#{@var}_flag"]
    else
      ["\"#{@var}_given:\"", "#{@var}_given", 
       "\" #{@var}_arg:\"", @multiple ? "yaggo::vec_str(#{@var}_arg)" : "#{@var}_arg"]
    end
  end

  def parse_arg
    return ["#{@var}_flag = true;"] if @type == :flag
    a = ["#{@var}_given = true;"]
    case @type
    when :string
      a << (@multiple ? "#{@var}_arg.push_back(#{str_conv("optarg", @type, false)});" : "#{@var}_arg.assign(optarg);")
    when :c_string
      a << (@multiple ? "#{@var}_arg.push_back(#{str_conv("optarg", @type, false)});" : "#{@var}_arg = optarg;")
    when :uint32, :uint64, :int32, :int64, :double
      a << (@multiple ? "#{@var}_arg.push_back(#{str_conv("optarg", @type, @suffix)});" : "#{@var}_arg = #{str_conv("optarg", @type, @suffix)};")
      a << "CHECK_ERR(#{@type}_t, optarg, \"#{switches}\")" 
    end
    a
  end
end

class Arg
  attr_accessor :description, :type, :default, :typestr, :multiple, :at_least
  attr_accessor :suffix
  attr_reader :name
  def initialize(str)
    @name = str
    @type = :string
    @at_least = 0
    @suffix = false
  end

  def check; true; end

  def var_decl
    if @multiple
      ["std::vector<#{$type_to_C_type[@type]}>".ljust($typejust) + " #{@name}_arg;"]
    else
      ["#{$type_to_C_type[@type]}".ljust($typejust) + " #{@name}_arg;"]
    end
  end

  def dump
    ["\"#{@name}_arg:\"",
     @multiple ? "yaggo::vec_str(#{@name}_arg)" : "#{@name}_arg"]
  end

  def parse_arg
    a = []
    off = ""
    if @multiple
      a << "for( ; optind < argc; ++optind) {"
      a << "  #{@name}_arg.push_back(#{str_conv("argv[optind]", @type, @suffix)});"
      off = "  "
    else
      a << "#{@name}_arg = #{str_conv("argv[optind]", @type, @suffix)};"
    end
    unless @type == :string || @type == :c_string
      a << (off + "CHECK_ERR(#{@type}_t, argv[optind], \"#{@name}\")")
    end
    a << (@multiple ? "}" : "++optind;")
    a
  end
end

def option(name1, name2 = nil)
  long = short = nil
  if name1 =~ /^--/ || name1.length >= 2
    long, short = name1, name2
  elsif !name2.nil? && (name2 =~ /^--/ || name2.length >= 2)
    long, short = name2, name1
  else
    long, short = nil, name1
  end

  long.gsub!(/^--/, "") unless long.nil?
  short.gsub!(/^-/, "") unless short.nil?
  o = Option.new(long, short)
  $options << o
  $target = o
  begin
    yield
  ensure
    $target = NoTarget.new
  end
end

def arg(name)
  a = Arg.new(name)
  $args << a
  $target = a
  begin
    yield
  ensure
    $target = NoTarget.new
  end
end

def output_cpp_parser(h, class_name)
  $options.each { |o| o.check }
  $args.each { |a| a.check }
  if $args.size > 1 && $args[0..-2].any? { |a| a.multiple }
    raise "Only last arg can be marked 'multiple'"
  end

  # Headers

  h.puts(<<EOS)
#ifndef __#{class_name.upcase()}_HPP__
#define __#{class_name.upcase()}_HPP__

#include #{$inc_path}

class #{class_name} {
public:
EOS

  ($options + $args).each { |o| h.puts("  " + o.var_decl.join("\n  ")) }
  h.puts("")

  # Create enum if option with no short version
  only_long = $options.map { |o| o.long_enum }.compact
  need_full = $options.any? { |o| o.hidden }
  help_no_h = $options.any? { |o| o.short == "h" }
  version_no_V = $options.any? { |o| o.short == "V" }
  h.print("  enum {\n    USAGE_OPT = 1000")
  h.print(",\n    FULL_HELP_OPT") if need_full
  h.print(",\n    HELP_OPT") if help_no_h
  if only_long.empty?
    h.puts("\n  };")
  else
    h.puts(",", "    " + only_long.join(",\n    "), "  };")
  end

  # Constructor and initialization
  h.puts("", "  #{class_name}(int argc, char *argv[]) :")
  h.puts("    " + $options.map { |o| o.init }.join(",\n    "))
  h.puts("  {",
         "    static struct option long_options[] = {")
  h.puts("      " + $options.map { |o| o.struct }.join(",\n      ") + ",")
  h.puts("      {\"help\", 0, 0, #{help_no_h ? "HELP_OPT" : "'h'"}},")
  h.puts("      {\"full-help\", 0, 0, FULL_HELP_OPT},") if need_full
  h.puts("      {\"usage\", 0, 0, USAGE_OPT},",
         "      {\"version\", 0, 0, 'V'},",
         "      {0, 0, 0, 0}", "    };")
  short_str = $options.map { |o| o.short_str }.compact.join("")
  h.puts("    static const char *short_options = \"hV#{short_str}\";", "")

  need_err   = $options.any? { |o| o.type != :flag && o.type != :string && o.type != :c_string}
  need_err ||= $args.any? { |a| a.type != :string && a.type != :c_string }
  h.puts("    std::string err;") if need_err

  # Actual parsing
  h.puts(<<EOS)
#define CHECK_ERR(type,val,which) if(!err.empty()) { std::cerr << "Invalid " #type " '" << val << "' for [" which "]: " << err << "\\n"; exit(1); }
    while(true) { 
      int index = -1;
      int c = getopt_long(argc, argv, short_options, long_options, &index);
      if(c == -1) break;
      switch(c) {
      case ':': 
        std::cerr << \"Missing required argument for \"
                  << (index == -1 ? std::string(1, (char)optopt) : std::string(long_options[index].name))
                  << std::endl;
        exit(1);
      case #{help_no_h ? "HELP_OPT" : "'h'"}:
        std::cout << usage() << \"\\n\\n\" << help() << std::endl;
        exit(0);
      case USAGE_OPT:
        std::cout << usage() << \"\\nUse --help for more information.\" << std::endl;
        exit(0);
      case 'V':
        print_version();
        exit(0);
      case '?':
        std::cerr << \"Use --usage or --help for some help\\n\";
        exit(1);
EOS
  if need_full
    h.puts(<<EOS)
      case FULL_HELP_OPT:
        std::cout << usage() << \"\\n\\n\" << help() << \"\\n\\n\" << hidden() << std::endl;
        exit(0);
EOS
  end
  
  $options.each { |o|
    h.puts("      case #{o.long_enum || "'" + o.short + "'"}:",
           "        " + o.parse_arg.join("\n        "),
           "        break;")
  }
  h.puts("      }", # close case
         "    }") # close while(true)

  # Check required
  $options.each { |o|
    next unless o.required
    h.puts(<<EOS)
    if(!#{o.var}_given)
      error("[#{o.switches}] required switch");
EOS
  }
  
  # Parse arguments
  if $args.size == 0 || !$args[-1].multiple
    h.puts(<<EOS)
    if(argc - optind != #{$args.size})
      error("Requires exactly #{$args.size} argument#{$args.size > 1 ? "s" : ""}.");
EOS
  else
    min_args = $args.size - 1 + $args[-1].at_least
    h.puts(<<EOS)
    if(argc - optind < #{min_args})
      error("Requires at least #{min_args} argument#{min_args > 1 ? "s" : ""}.");
EOS
  end
  $args.each { |a| h.puts("    " + a.parse_arg.join("\n    ")) }

  h.puts("  }") # close constructor

  # Usage
  h.print("#define #{class_name}_USAGE \"Usage: #{$package || class_name} [options]")
  $args.each { |a|
    h.print(" #{a.name}:#{a.typestr || a.type}#{a.multiple ? "+" : ""}") 
  }
  h.puts("\"")
  h.puts(<<EOS)
  const char * usage() const { return #{class_name}_USAGE; }
  void error(const char *msg) { 
    std::cerr << \"Error: \" << msg << \"\\n\" << usage()
              << \"\\nUse --help for more information\"
              << std::endl;
    exit(1);
  }
EOS

  # Help
  $description ||= "No description"
  desc = $description.split(/\n/).join("\\n\" \\\n  \"")
  h.puts(<<EOS)
#define #{class_name}_HELP "#{desc}\\n\\n" \\
  "Options (default value in (), *required):\\n" \\
EOS
  $options.each { |o|
    # need to be improved. break lines if too long
    next if o.hidden
    s = " " + o.switches
    if s.size >= $switchesjust
      s += "\\n" + "".ljust($switchesjust)
    else
      s = s.ljust($switchesjust)
    end
    h.puts("  \"#{s} #{o.help}\\n\" \\") 
  }
  h.puts("  \"#{"     --usage".ljust($switchesjust)}  Usage\\n\" \\")
  help_switch = " -h, "
  help_switch = " " * help_switch.size if help_no_h
  help_switch += "--help"
  h.puts("  \"#{help_switch.ljust($switchesjust)}  This message\\n\" \\")
  h.puts("  \"#{"     --full-help".ljust($switchesjust)}  Detailed help\\n\" \\") if need_full
  version_switch = " -V, "
  version_switch = " " * version_switch.size if version_no_V
  version_switch += "--version"
  h.puts(<<EOS)
  "#{version_switch.ljust($switchesjust)}  Version"

  const char * help() const { return #{class_name}_HELP; }
EOS

  # Hidden options
  h.print("#define #{class_name}_HIDDEN \"Hidden options:")
  $options.each { |o|
    # need to be improved. break lines if too long
    next unless o.hidden
    s = " " + o.switches
    if s.size >= $switchesjust
      s += "\\n" + "".ljust($switchesjust)
    else
      s = s.ljust($switchesjust)
    end
    h.print("\\n\" \\\n  \"#{s} #{o.help}") 
  }
  h.puts(<<EOS)
"

  const char * hidden() const { return #{class_name}_HIDDEN; }
EOS
  

  # Version
  h.puts("  void print_version(std::ostream &os = std::cout) const {",
         "#ifndef PACKAGE_VERSION",
         "#define PACKAGE_VERSION \"0.0.0\"",
         "#endif",
         "    os << #{$version ? "\"" + $version + "\"" : "PACKAGE_VERSION"} << \"\\n\";",
         "  }")
  
  # Dump
  h.puts("  void dump(std::ostream &os = std::cout) {")
  ($options + $args).each { |o| h.puts("    os << #{o.dump.join(" << ")} << \"\\n\";") }
  h.puts("  }")

  # Private methods
  h.puts(<<EOS)
private:
};

#endif // __#{class_name.upcase}_HPP__"
EOS
end

ARGV.each do |input_file|
  pid = fork do
    load(input_file)
    fsplit = File.basename(input_file).split(/\./)
    $class ||= fsplit.size > 1 ? fsplit[0..-2].join(".") : fsplit[0]
    $output ||= input_file.gsub(/\.yaggo$/, "") + ".hpp"

    begin
      out_fd = open($output, "w")
      output_cpp_parser(out_fd, $class)
    ensure
      out_fd.close if out_fd
    end
  end
  Process.waitpid pid
end
